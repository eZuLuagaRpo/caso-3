{"name": "POST /getReturns con tipos de datos inválidos devuelve 400", "status": "broken", "statusDetails": {"message": "ValueError: time data '123' does not match format '%Y-%m-%d'", "trace": "self = <financialSearch.tests.TestErrorHandlingImprovements object at 0x0000026EFFED3D90>\nlogged_in_client = <django.test.client.Client object at 0x0000026E8131FD90>, mock_yfinance = None\n\n    @allure.story(\"Tipos de Datos Inválidos\")\n    @allure.title(\"POST /getReturns con tipos de datos inválidos devuelve 400\")\n    @allure.description(\"Demuestra que enviar tipos de datos incorrectos (números y booleanos en lugar de strings) a /getReturns resulta en un código 400, resaltando la necesidad de validación en la vista.\")\n    @pytest.mark.django_db\n    def test_get_returns_invalid_data_types(self, logged_in_client, mock_yfinance):\n        data = {'from': 123, 'to': True, 'brand': 456}\n>       response = logged_in_client.post('/getReturns', data)\n\nfinancialSearch\\tests.py:243: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nenv\\Lib\\site-packages\\django\\test\\client.py:1153: in post\n    response = super().post(\nenv\\Lib\\site-packages\\django\\test\\client.py:499: in post\n    return self.generic(\nenv\\Lib\\site-packages\\django\\test\\client.py:671: in generic\n    return self.request(**r)\nenv\\Lib\\site-packages\\django\\test\\client.py:1087: in request\n    self.check_exception(response)\nenv\\Lib\\site-packages\\django\\test\\client.py:802: in check_exception\n    raise exc_value\nenv\\Lib\\site-packages\\django\\core\\handlers\\exception.py:55: in inner\n    response = get_response(request)\nenv\\Lib\\site-packages\\django\\core\\handlers\\base.py:197: in _get_response\n    response = wrapped_callback(request, *callback_args, **callback_kwargs)\nenv\\Lib\\site-packages\\django\\contrib\\auth\\decorators.py:59: in _view_wrapper\n    return view_func(request, *args, **kwargs)\nfinancialSearch\\views.py:51: in getReturns\n    start = datetime.strptime(from_date, '%Y-%m-%d')\nC:\\Users\\emanu\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\_strptime.py:676: in _strptime_datetime\n    tt, fraction, gmtoff_fraction = _strptime(data_string, format)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ndata_string = '123', format = '%Y-%m-%d'\n\n    def _strptime(data_string, format=\"%a %b %d %H:%M:%S %Y\"):\n        \"\"\"Return a 2-tuple consisting of a time struct and an int containing\n        the number of microseconds based on the input string and the\n        format string.\"\"\"\n    \n        for index, arg in enumerate([data_string, format]):\n            if not isinstance(arg, str):\n                msg = \"strptime() argument {} must be str, not {}\"\n                raise TypeError(msg.format(index, type(arg)))\n    \n        global _TimeRE_cache, _regex_cache\n        with _cache_lock:\n            locale_time = _TimeRE_cache.locale_time\n            if (_getlang() != locale_time.lang or\n                time.tzname != locale_time.tzname or\n                time.daylight != locale_time.daylight):\n                _TimeRE_cache = TimeRE()\n                _regex_cache.clear()\n                locale_time = _TimeRE_cache.locale_time\n            if len(_regex_cache) > _CACHE_MAX_SIZE:\n                _regex_cache.clear()\n            format_regex = _regex_cache.get(format)\n            if not format_regex:\n                try:\n                    format_regex = _TimeRE_cache.compile(format)\n                # KeyError raised when a bad format is found; can be specified as\n                # \\\\, in which case it was a stray % but with a space after it\n                except KeyError as err:\n                    bad_directive = err.args[0]\n                    if bad_directive == \"\\\\\":\n                        bad_directive = \"%\"\n                    del err\n                    raise ValueError(\"'%s' is a bad directive in format '%s'\" %\n                                        (bad_directive, format)) from None\n                # IndexError only occurs when the format string is \"%\"\n                except IndexError:\n                    raise ValueError(\"stray %% in format '%s'\" % format) from None\n                _regex_cache[format] = format_regex\n        found = format_regex.match(data_string)\n        if not found:\n>           raise ValueError(\"time data %r does not match format %r\" %\n                             (data_string, format))\nE           ValueError: time data '123' does not match format '%Y-%m-%d'\n\nC:\\Users\\emanu\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\_strptime.py:455: ValueError"}, "description": "Demuestra que enviar tipos de datos incorrectos (números y booleanos en lugar de strings) a /getReturns resulta en un código 400, resaltando la necesidad de validación en la vista.", "attachments": [{"name": "log", "source": "85c08c58-1ecd-4db3-b884-0e975fcb8d2a-attachment.txt", "type": "text/plain"}], "start": 1746830297334, "stop": 1746830297336, "uuid": "125e4a29-fabc-452e-b78c-6cd88d9dece9", "historyId": "722431917a25f22a7355d9e068a54f11", "testCaseId": "722431917a25f22a7355d9e068a54f11", "fullName": "financialSearch.tests.TestErrorHandlingImprovements#test_get_returns_invalid_data_types", "labels": [{"name": "feature", "value": "Mejoras en el Manejo de Errores"}, {"name": "story", "value": "Tipos de Datos Inválidos"}, {"name": "tag", "value": "django_db"}, {"name": "parentSuite", "value": "financialSearch"}, {"name": "suite", "value": "tests"}, {"name": "subSuite", "value": "TestErrorHandlingImprovements"}, {"name": "host", "value": "emanuelZuluaga"}, {"name": "thread", "value": "11384-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "financialSearch.tests"}]}