{"name": "Prueba paramétrica para /getReturns con diferentes entradas", "status": "broken", "statusDetails": {"message": "ValueError: time data '' does not match format '%Y-%m-%d'", "trace": "self = <financialSearch.tests.TestGetReturnsParametric object at 0x0000025F69899B50>\nlogged_in_client = <django.test.client.Client object at 0x0000025F6AB356D0>, mock_yfinance = None, from_date = '2023-01-01', to_date = '', brand = 'AAPL'\nexpected_status = 400, expected_error = 'Faltan campos requeridos.'\n\n    @allure.story(\"Casos Varios de Obtención de Datos\")\n    @allure.title(\"Prueba paramétrica para /getReturns con diferentes entradas\")\n    @allure.description(\"Evalúa el comportamiento de /getReturns con múltiples combinaciones de entradas, incluyendo casos válidos, fechas invertidas, tickers inválidos, formatos incorrectos y campos faltantes.\")\n    @allure.severity(allure.severity_level.NORMAL)\n    @pytest.mark.parametrize(\n        \"from_date,to_date,brand,expected_status,expected_error\",\n        [\n            # Caso de éxito: Fechas válidas y ticker válido\n            ('2023-01-01', '2023-01-05', 'AAPL', 200, None),\n            # Fechas invertidas: from > to\n            ('2023-01-05', '2023-01-01', 'AAPL', 404, 'No se encontraron datos para el ticker y rango de fechas dados.'),\n            # Ticker inválido\n            ('2023-01-01', '2023-01-05', 'INVALID', 404, 'No se encontraron datos para el ticker y rango de fechas dados.'),\n            # Fecha inválida: Formato incorrecto\n            ('invalid-date', '2023-01-05', 'AAPL', 400, 'Formato de fecha inválido.'),\n            # Campos faltantes: Falta 'to'\n            ('2023-01-01', '', 'AAPL', 400, 'Faltan campos requeridos.'),\n            # Campos faltantes: Falta 'from'\n            ('', '2023-01-05', 'AAPL', 400, 'Faltan campos requeridos.'),\n            # Fechas iguales: Comprobar comportamiento con rango de un solo día\n            ('2023-01-01', '2023-01-01', 'AAPL', 200, None),\n            # Fechas en el futuro: No deberían devolver datos\n            ('2025-01-01', '2025-01-05', 'AAPL', 404, 'No se encontraron datos para el ticker y rango de fechas dados.')\n        ]\n    )\n    @pytest.mark.django_db\n    def test_get_returns_parametric(self, logged_in_client, mock_yfinance, from_date, to_date, brand, expected_status, expected_error):\n        data = {'from': from_date, 'to': to_date, 'brand': brand}\n>       response = logged_in_client.post('/getReturns', data)\n\nfinancialSearch\\tests.py:269: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nenv\\Lib\\site-packages\\django\\test\\client.py:1153: in post\n    response = super().post(\nenv\\Lib\\site-packages\\django\\test\\client.py:499: in post\n    return self.generic(\nenv\\Lib\\site-packages\\django\\test\\client.py:671: in generic\n    return self.request(**r)\nenv\\Lib\\site-packages\\django\\test\\client.py:1087: in request\n    self.check_exception(response)\nenv\\Lib\\site-packages\\django\\test\\client.py:802: in check_exception\n    raise exc_value\nenv\\Lib\\site-packages\\django\\core\\handlers\\exception.py:55: in inner\n    response = get_response(request)\nenv\\Lib\\site-packages\\django\\core\\handlers\\base.py:197: in _get_response\n    response = wrapped_callback(request, *callback_args, **callback_kwargs)\nenv\\Lib\\site-packages\\django\\contrib\\auth\\decorators.py:59: in _view_wrapper\n    return view_func(request, *args, **kwargs)\nfinancialSearch\\views.py:47: in getReturns\n    end = datetime.strptime(to_date, '%Y-%m-%d')\nC:\\Users\\emanu\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\_strptime.py:676: in _strptime_datetime\n    tt, fraction, gmtoff_fraction = _strptime(data_string, format)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ndata_string = '', format = '%Y-%m-%d'\n\n    def _strptime(data_string, format=\"%a %b %d %H:%M:%S %Y\"):\n        \"\"\"Return a 2-tuple consisting of a time struct and an int containing\n        the number of microseconds based on the input string and the\n        format string.\"\"\"\n    \n        for index, arg in enumerate([data_string, format]):\n            if not isinstance(arg, str):\n                msg = \"strptime() argument {} must be str, not {}\"\n                raise TypeError(msg.format(index, type(arg)))\n    \n        global _TimeRE_cache, _regex_cache\n        with _cache_lock:\n            locale_time = _TimeRE_cache.locale_time\n            if (_getlang() != locale_time.lang or\n                time.tzname != locale_time.tzname or\n                time.daylight != locale_time.daylight):\n                _TimeRE_cache = TimeRE()\n                _regex_cache.clear()\n                locale_time = _TimeRE_cache.locale_time\n            if len(_regex_cache) > _CACHE_MAX_SIZE:\n                _regex_cache.clear()\n            format_regex = _regex_cache.get(format)\n            if not format_regex:\n                try:\n                    format_regex = _TimeRE_cache.compile(format)\n                # KeyError raised when a bad format is found; can be specified as\n                # \\\\, in which case it was a stray % but with a space after it\n                except KeyError as err:\n                    bad_directive = err.args[0]\n                    if bad_directive == \"\\\\\":\n                        bad_directive = \"%\"\n                    del err\n                    raise ValueError(\"'%s' is a bad directive in format '%s'\" %\n                                        (bad_directive, format)) from None\n                # IndexError only occurs when the format string is \"%\"\n                except IndexError:\n                    raise ValueError(\"stray %% in format '%s'\" % format) from None\n                _regex_cache[format] = format_regex\n        found = format_regex.match(data_string)\n        if not found:\n>           raise ValueError(\"time data %r does not match format %r\" %\n                             (data_string, format))\nE           ValueError: time data '' does not match format '%Y-%m-%d'\n\nC:\\Users\\emanu\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\_strptime.py:455: ValueError"}, "description": "Evalúa el comportamiento de /getReturns con múltiples combinaciones de entradas, incluyendo casos válidos, fechas invertidas, tickers inválidos, formatos incorrectos y campos faltantes.", "attachments": [{"name": "log", "source": "3c75aba7-adac-46fc-89f9-f0910fab9afb-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "from_date", "value": "'2023-01-01'"}, {"name": "to_date", "value": "''"}, {"name": "brand", "value": "'AAPL'"}, {"name": "expected_status", "value": "400"}, {"name": "expected_error", "value": "'Faltan campos requeridos.'"}], "start": 1747101493537, "stop": 1747101493539, "uuid": "74dad93d-8e3c-42d3-be19-6f2c8acc9cd4", "historyId": "bbdbeddd0aa3fe694142e119c161569e", "testCaseId": "32d5fb6ac01426c90cd3f74050119a60", "fullName": "financialSearch.tests.TestGetReturnsParametric#test_get_returns_parametric", "labels": [{"name": "story", "value": "Casos Varios de Obtención de Datos"}, {"name": "feature", "value": "Obtención de Datos Financieros"}, {"name": "severity", "value": "normal"}, {"name": "tag", "value": "django_db"}, {"name": "parentSuite", "value": "financialSearch"}, {"name": "suite", "value": "tests"}, {"name": "subSuite", "value": "TestGetReturnsParametric"}, {"name": "host", "value": "emanuelZuluaga"}, {"name": "thread", "value": "20020-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "financialSearch.tests"}]}